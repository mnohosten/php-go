package compiler

import (
	"fmt"

	"github.com/krizos/php-go/pkg/ast"
	"github.com/krizos/php-go/pkg/vm"
)

// Compiler compiles PHP AST into VM bytecode
type Compiler struct {
	// instructions holds the generated bytecode
	instructions vm.Instructions

	// constants holds literal values referenced by the bytecode
	constants []interface{}

	// constantMap maps constant values to their indices for deduplication
	constantMap map[interface{}]int

	// symbolTable manages variable scopes
	symbolTable *SymbolTable

	// lastInstruction tracks the most recently emitted instruction
	lastInstruction EmittedInstruction

	// previousInstruction tracks the instruction before lastInstruction
	previousInstruction EmittedInstruction

	// loopStack tracks nested loops for break/continue
	loopStack []*LoopContext
}

// LoopContext tracks information about a loop for break/continue
type LoopContext struct {
	// startPos is the position to jump to for continue
	startPos int

	// breakJumps holds positions of break statements to be patched
	breakJumps []int

	// continueJumps holds positions of continue statements to be patched
	continueJumps []int
}

// EmittedInstruction tracks metadata about an emitted instruction
type EmittedInstruction struct {
	Opcode   vm.Opcode
	Position int
}

// New creates a new compiler instance
func New() *Compiler {
	c := &Compiler{
		instructions:        vm.Instructions{},
		constants:           []interface{}{},
		constantMap:         make(map[interface{}]int),
		lastInstruction:     EmittedInstruction{},
		previousInstruction: EmittedInstruction{},
	}
	c.InitSymbolTable()
	return c
}

// ========================================
// Constant Table Management
// ========================================

// AddConstant adds a constant to the constant table
// Returns the index of the constant (reuses existing if duplicate)
func (c *Compiler) AddConstant(value interface{}) int {
	// Check if constant already exists
	if idx, ok := c.constantMap[value]; ok {
		return idx
	}

	// Add new constant
	idx := len(c.constants)
	c.constants = append(c.constants, value)
	c.constantMap[value] = idx
	return idx
}

// GetConstant retrieves a constant by index
func (c *Compiler) GetConstant(idx int) (interface{}, error) {
	if idx < 0 || idx >= len(c.constants) {
		return nil, fmt.Errorf("constant index out of bounds: %d", idx)
	}
	return c.constants[idx], nil
}

// Constants returns a copy of the constant table
func (c *Compiler) Constants() []interface{} {
	result := make([]interface{}, len(c.constants))
	copy(result, c.constants)
	return result
}

// ========================================
// Opcode Emission
// ========================================

// Emit emits an instruction with the given opcode and operands
// Returns the position of the emitted instruction
func (c *Compiler) Emit(opcode vm.Opcode, operands ...vm.Operand) int {
	return c.EmitWithLine(opcode, 0, operands...)
}

// EmitWithLine emits an instruction with line number information
// Returns the position of the emitted instruction
func (c *Compiler) EmitWithLine(opcode vm.Opcode, lineno uint32, operands ...vm.Operand) int {
	instr := vm.Instruction{
		Opcode: opcode,
		Lineno: lineno,
	}

	// Set operands based on count
	if len(operands) > 0 {
		instr.Op1 = operands[0]
	}
	if len(operands) > 1 {
		instr.Op2 = operands[1]
	}
	if len(operands) > 2 {
		instr.Result = operands[2]
	}

	pos := c.addInstruction(instr)

	// Update instruction tracking
	c.previousInstruction = c.lastInstruction
	c.lastInstruction = EmittedInstruction{
		Opcode:   opcode,
		Position: pos,
	}

	return pos
}

// EmitWithExtended emits an instruction with an extended value
func (c *Compiler) EmitWithExtended(opcode vm.Opcode, lineno uint32, extended uint32, operands ...vm.Operand) int {
	instr := vm.Instruction{
		Opcode:        opcode,
		Lineno:        lineno,
		ExtendedValue: extended,
	}

	// Set operands based on count
	if len(operands) > 0 {
		instr.Op1 = operands[0]
	}
	if len(operands) > 1 {
		instr.Op2 = operands[1]
	}
	if len(operands) > 2 {
		instr.Result = operands[2]
	}

	pos := c.addInstruction(instr)

	// Update instruction tracking
	c.previousInstruction = c.lastInstruction
	c.lastInstruction = EmittedInstruction{
		Opcode:   opcode,
		Position: pos,
	}

	return pos
}

// addInstruction adds an instruction to the instruction list
func (c *Compiler) addInstruction(instr vm.Instruction) int {
	pos := len(c.instructions)
	c.instructions = append(c.instructions, instr)
	return pos
}

// ========================================
// Instruction Manipulation
// ========================================

// ReplaceInstruction replaces the instruction at the given position
func (c *Compiler) ReplaceInstruction(pos int, instr vm.Instruction) error {
	if pos < 0 || pos >= len(c.instructions) {
		return fmt.Errorf("instruction position out of bounds: %d", pos)
	}
	c.instructions[pos] = instr
	return nil
}

// ChangeOperand changes an operand in an instruction at the given position
func (c *Compiler) ChangeOperand(pos int, operandNum int, operand vm.Operand) error {
	if pos < 0 || pos >= len(c.instructions) {
		return fmt.Errorf("instruction position out of bounds: %d", pos)
	}

	instr := c.instructions[pos]
	switch operandNum {
	case 1:
		instr.Op1 = operand
	case 2:
		instr.Op2 = operand
	case 3:
		instr.Result = operand
	default:
		return fmt.Errorf("invalid operand number: %d (must be 1, 2, or 3)", operandNum)
	}

	c.instructions[pos] = instr
	return nil
}

// CurrentPosition returns the position where the next instruction will be emitted
func (c *Compiler) CurrentPosition() int {
	return len(c.instructions)
}

// LastInstructionIs checks if the last instruction is the given opcode
func (c *Compiler) LastInstructionIs(opcode vm.Opcode) bool {
	return c.lastInstruction.Opcode == opcode
}

// RemoveLastInstruction removes the last emitted instruction
// Used for optimizations (e.g., removing unnecessary OpPop)
func (c *Compiler) RemoveLastInstruction() {
	if len(c.instructions) == 0 {
		return
	}

	c.instructions = c.instructions[:c.lastInstruction.Position]
	c.lastInstruction = c.previousInstruction
}

// ========================================
// Program Assembly
// ========================================

// Bytecode represents the compiled bytecode program
type Bytecode struct {
	Instructions vm.Instructions
	Constants    []interface{}
}

// Bytecode assembles and returns the final compiled bytecode
func (c *Compiler) Bytecode() *Bytecode {
	return &Bytecode{
		Instructions: c.instructions,
		Constants:    c.constants,
	}
}

// ========================================
// Compilation Entry Point
// ========================================

// Compile compiles an AST program into bytecode
func (c *Compiler) Compile(node ast.Node) error {
	switch node := node.(type) {
	case *ast.Program:
		for _, stmt := range node.Statements {
			if err := c.Compile(stmt); err != nil {
				return err
			}
		}
		return nil

	// Statements
	case *ast.ExpressionStatement:
		if err := c.Compile(node.Expression); err != nil {
			return err
		}
		// Pop the result since expression statements don't use their value
		c.Emit(vm.OpFree, vm.TmpVarOperand(0)) // TODO: track temp var numbers properly
		return nil

	case *ast.BlockStatement:
		for _, stmt := range node.Statements {
			if err := c.Compile(stmt); err != nil {
				return err
			}
		}
		return nil

	case *ast.EchoStatement:
		for _, expr := range node.Expressions {
			if err := c.Compile(expr); err != nil {
				return err
			}
			// Emit ECHO instruction for each expression
			c.EmitWithLine(vm.OpEcho, uint32(node.Token.Pos.Line), vm.TmpVarOperand(0))
		}
		return nil

	case *ast.ReturnStatement:
		if node.ReturnValue != nil {
			if err := c.Compile(node.ReturnValue); err != nil {
				return err
			}
			c.EmitWithLine(vm.OpReturn, uint32(node.Token.Pos.Line), vm.TmpVarOperand(0))
		} else {
			// Return null
			c.EmitWithLine(vm.OpReturn, uint32(node.Token.Pos.Line))
		}
		return nil

	// Literals
	case *ast.IntegerLiteral:
		constIdx := c.AddConstant(node.Value)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	case *ast.FloatLiteral:
		constIdx := c.AddConstant(node.Value)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	case *ast.StringLiteral:
		constIdx := c.AddConstant(node.Value)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	case *ast.BooleanLiteral:
		constIdx := c.AddConstant(node.Value)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	case *ast.NullLiteral:
		constIdx := c.AddConstant(nil)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	// Infix Expressions (binary operators)
	case *ast.InfixExpression:
		// Compile left operand
		if err := c.Compile(node.Left); err != nil {
			return err
		}
		leftTemp := vm.TmpVarOperand(0) // TODO: proper temp tracking

		// Compile right operand
		if err := c.Compile(node.Right); err != nil {
			return err
		}
		rightTemp := vm.TmpVarOperand(1) // TODO: proper temp tracking

		// Emit the appropriate opcode based on operator
		var opcode vm.Opcode
		switch node.Operator {
		case "+":
			opcode = vm.OpAdd
		case "-":
			opcode = vm.OpSub
		case "*":
			opcode = vm.OpMul
		case "/":
			opcode = vm.OpDiv
		case "%":
			opcode = vm.OpMod
		case "**":
			opcode = vm.OpPow
		case ".":
			opcode = vm.OpConcat
		case "==":
			opcode = vm.OpIsEqual
		case "!=":
			opcode = vm.OpIsNotEqual
		case "===":
			opcode = vm.OpIsIdentical
		case "!==":
			opcode = vm.OpIsNotIdentical
		case "<":
			opcode = vm.OpIsSmaller
		case "<=":
			opcode = vm.OpIsSmallerOrEqual
		case ">":
			// Swap operands and use IS_SMALLER
			opcode = vm.OpIsSmaller
			leftTemp, rightTemp = rightTemp, leftTemp
		case ">=":
			// Swap operands and use IS_SMALLER_OR_EQUAL
			opcode = vm.OpIsSmallerOrEqual
			leftTemp, rightTemp = rightTemp, leftTemp
		case "|":
			opcode = vm.OpBWOr
		case "&":
			opcode = vm.OpBWAnd
		case "^":
			opcode = vm.OpBWXor
		case "<<":
			opcode = vm.OpSL
		case ">>":
			opcode = vm.OpSR
		case "<=>":
			opcode = vm.OpSpaceship
		default:
			return fmt.Errorf("unknown infix operator: %s", node.Operator)
		}

		c.EmitWithLine(opcode, uint32(node.Token.Pos.Line),
			leftTemp,
			rightTemp,
			vm.TmpVarOperand(2)) // Result in temp 2
		return nil

	// Prefix Expressions (unary operators)
	case *ast.PrefixExpression:
		// Compile operand
		if err := c.Compile(node.Right); err != nil {
			return err
		}

		// Emit the appropriate opcode
		var opcode vm.Opcode
		switch node.Operator {
		case "!":
			opcode = vm.OpBoolNot
		case "-":
			// Unary minus: 0 - operand
			constIdx := c.AddConstant(int64(0))
			c.EmitWithLine(vm.OpSub, uint32(node.Token.Pos.Line),
				vm.ConstOperand(uint32(constIdx)),
				vm.TmpVarOperand(0),
				vm.TmpVarOperand(1))
			return nil
		case "~":
			opcode = vm.OpBWNot
		default:
			return fmt.Errorf("unknown prefix operator: %s", node.Operator)
		}

		c.EmitWithLine(opcode, uint32(node.Token.Pos.Line),
			vm.TmpVarOperand(0),
			vm.UnusedOperand(),
			vm.TmpVarOperand(1))
		return nil

	case *ast.Variable:
		// Look up the variable in the symbol table
		symbol, ok := c.ResolveVariable(node.Name)
		if !ok {
			// Variable not defined, define it now (PHP allows implicit declaration)
			symbol = c.DefineVariable(node.Name)
		}

		// Emit FETCH instruction based on scope
		switch symbol.Scope {
		case GlobalScope:
			// Fetch global variable
			c.EmitWithLine(vm.OpFetchR, uint32(node.Token.Pos.Line),
				vm.CVOperand(uint32(symbol.Index)),
				vm.UnusedOperand(),
				vm.TmpVarOperand(0))
		case LocalScope:
			// Fetch local variable (compiled variable for direct access)
			c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
				vm.CVOperand(uint32(symbol.Index)),
				vm.UnusedOperand(),
				vm.TmpVarOperand(0))
		case BuiltinScope:
			return fmt.Errorf("cannot use builtin '%s' as variable", node.Name)
		case FreeScope:
			// Fetch free variable (closure variable)
			c.EmitWithLine(vm.OpFetchR, uint32(node.Token.Pos.Line),
				vm.CVOperand(uint32(symbol.Index)),
				vm.UnusedOperand(),
				vm.TmpVarOperand(0))
		}
		return nil

	case *ast.AssignmentExpression:
		// Compile the right side first
		if err := c.Compile(node.Right); err != nil {
			return err
		}

		// Handle the left side (variable)
		if variable, ok := node.Left.(*ast.Variable); ok {
			// Look up or define the variable
			symbol, ok := c.ResolveVariable(variable.Name)
			if !ok {
				symbol = c.DefineVariable(variable.Name)
			}

			// Emit ASSIGN instruction
			c.EmitWithLine(vm.OpAssign, uint32(node.Token.Pos.Line),
				vm.TmpVarOperand(0), // Value is in temp var 0
				vm.UnusedOperand(),
				vm.CVOperand(uint32(symbol.Index))) // Store in compiled variable
			return nil
		}

		return fmt.Errorf("assignment to non-variable not yet implemented")

	// Identifier (convert to string constant)
	case *ast.Identifier:
		constIdx := c.AddConstant(node.Value)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	// Grouped Expression (just compile the inner expression)
	case *ast.GroupedExpression:
		return c.Compile(node.Expr)

	// Array Literal
	case *ast.ArrayExpression:
		// Initialize empty array
		c.EmitWithLine(vm.OpInitArray, uint32(node.Token.Pos.Line),
			vm.UnusedOperand(),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0)) // Array in temp var 0

		// Add elements to array
		for _, elem := range node.Elements {
			// Compile the value
			if err := c.Compile(elem.Value); err != nil {
				return err
			}
			valueTemp := vm.TmpVarOperand(1) // Value in temp 1

			// If there's a key, compile it
			if elem.Key != nil {
				if err := c.Compile(elem.Key); err != nil {
					return err
				}
				keyTemp := vm.TmpVarOperand(2) // Key in temp 2

				// ADD_ARRAY_ELEMENT with key: array[key] = value
				c.EmitWithLine(vm.OpAddArrayElement, uint32(node.Token.Pos.Line),
					valueTemp,
					keyTemp,
					vm.TmpVarOperand(0)) // Result array in temp 0
			} else {
				// ADD_ARRAY_ELEMENT without key: array[] = value
				c.EmitWithLine(vm.OpAddArrayElement, uint32(node.Token.Pos.Line),
					valueTemp,
					vm.UnusedOperand(),
					vm.TmpVarOperand(0)) // Result array in temp 0
			}
		}
		return nil

	// Array Access
	case *ast.IndexExpression:
		// Compile the array/string
		if err := c.Compile(node.Left); err != nil {
			return err
		}
		arrayTemp := vm.TmpVarOperand(0)

		// Compile the index
		if err := c.Compile(node.Index); err != nil {
			return err
		}
		indexTemp := vm.TmpVarOperand(1)

		// Emit FETCH_DIM_R: result = array[index]
		c.EmitWithLine(vm.OpFetchDimR, uint32(node.Token.Pos.Line),
			arrayTemp,
			indexTemp,
			vm.TmpVarOperand(2)) // Result in temp 2
		return nil

	// Property Access
	case *ast.PropertyExpression:
		// Compile the object
		if err := c.Compile(node.Object); err != nil {
			return err
		}
		objTemp := vm.TmpVarOperand(0)

		// Compile the property (could be identifier or dynamic expression)
		if err := c.Compile(node.Property); err != nil {
			return err
		}
		propTemp := vm.TmpVarOperand(1)

		// Emit FETCH_OBJ_R: result = obj->prop
		c.EmitWithLine(vm.OpFetchObjR, uint32(node.Token.Pos.Line),
			objTemp,
			propTemp,
			vm.TmpVarOperand(2)) // Result in temp 2
		return nil

	// Function Call
	case *ast.CallExpression:
		// For now, we'll handle simple function calls by name
		// Full implementation with dynamic calls will come later

		// Compile arguments first
		for _, arg := range node.Arguments {
			if err := c.Compile(arg); err != nil {
				return err
			}
			// TODO: Push arguments onto stack properly
		}

		// Compile the function expression
		if err := c.Compile(node.Function); err != nil {
			return err
		}
		funcTemp := vm.TmpVarOperand(0)

		// Initialize function call
		c.EmitWithLine(vm.OpInitFcallByName, uint32(node.Token.Pos.Line),
			funcTemp,
			vm.ConstOperand(uint32(len(node.Arguments))), // Argument count
			vm.UnusedOperand())

		// Execute function call
		c.EmitWithLine(vm.OpDoFcall, uint32(node.Token.Pos.Line),
			vm.UnusedOperand(),
			vm.UnusedOperand(),
			vm.TmpVarOperand(1)) // Result in temp 1
		return nil

	// Method Call
	case *ast.MethodCallExpression:
		// Compile the object
		if err := c.Compile(node.Object); err != nil {
			return err
		}
		objTemp := vm.TmpVarOperand(0)

		// Compile the method name (could be identifier or dynamic)
		if err := c.Compile(node.Method); err != nil {
			return err
		}
		methodTemp := vm.TmpVarOperand(1)

		// Compile arguments
		for _, arg := range node.Arguments {
			if err := c.Compile(arg); err != nil {
				return err
			}
			// TODO: Push arguments onto stack properly
		}

		// Initialize method call
		c.EmitWithLine(vm.OpInitMethodCall, uint32(node.Token.Pos.Line),
			objTemp,
			methodTemp,
			vm.UnusedOperand())

		// Execute method call with argument count in extended value
		c.EmitWithExtended(vm.OpDoFcall, uint32(node.Token.Pos.Line),
			uint32(len(node.Arguments)),
			vm.UnusedOperand(),
			vm.UnusedOperand(),
			vm.TmpVarOperand(2)) // Result in temp 2
		return nil

	// Ternary Operator
	case *ast.TernaryExpression:
		// Compile the condition
		if err := c.Compile(node.Condition); err != nil {
			return err
		}

		// Short ternary form: $x ?: $y (if $x is falsy, use $y)
		if node.Consequence == nil {
			// Use JMP_SET: if (condition) { result = condition; goto end; }
			// Emit JMP_SET with placeholder address
			jmpSetPos := c.EmitWithLine(vm.OpJmpSet, uint32(node.Token.Pos.Line),
				vm.TmpVarOperand(0),
				vm.UnusedOperand(),
				vm.TmpVarOperand(1)) // Result in temp 1

			// Compile alternative (used if condition is falsy)
			if err := c.Compile(node.Alternative); err != nil {
				return err
			}
			// Move alternative to result
			c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
				vm.TmpVarOperand(0),
				vm.UnusedOperand(),
				vm.TmpVarOperand(1))

			// Patch JMP_SET to jump here
			endPos := c.CurrentPosition()
			c.ChangeOperand(jmpSetPos, 2, vm.ConstOperand(uint32(endPos)))
			return nil
		}

		// Full ternary form: $x ? $y : $z
		// JMPZ consequence_end with placeholder
		jmpzPos := c.EmitWithLine(vm.OpJmpZ, uint32(node.Token.Pos.Line),
			vm.TmpVarOperand(0),
			vm.UnusedOperand(),
			vm.UnusedOperand())

		// Compile consequence (true branch)
		if err := c.Compile(node.Consequence); err != nil {
			return err
		}
		// Move consequence to result
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.TmpVarOperand(0),
			vm.UnusedOperand(),
			vm.TmpVarOperand(1)) // Result in temp 1

		// JMP to end with placeholder
		jmpEndPos := c.EmitWithLine(vm.OpJmp, uint32(node.Token.Pos.Line),
			vm.UnusedOperand(),
			vm.UnusedOperand(),
			vm.UnusedOperand())

		// Patch JMPZ to jump to alternative
		altPos := c.CurrentPosition()
		c.ChangeOperand(jmpzPos, 1, vm.ConstOperand(uint32(altPos)))

		// Compile alternative (false branch)
		if err := c.Compile(node.Alternative); err != nil {
			return err
		}
		// Move alternative to result
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.TmpVarOperand(0),
			vm.UnusedOperand(),
			vm.TmpVarOperand(1))

		// Patch JMP to jump to end
		endPos := c.CurrentPosition()
		c.ChangeOperand(jmpEndPos, 1, vm.ConstOperand(uint32(endPos)))
		return nil

	// Type Cast
	case *ast.CastExpression:
		// Compile the expression to cast
		if err := c.Compile(node.Expr); err != nil {
			return err
		}

		// Map cast type to opcode extended value
		var castType uint32
		switch node.Type {
		case "int", "integer":
			castType = 1
		case "bool", "boolean":
			castType = 2
		case "float", "double", "real":
			castType = 3
		case "string":
			castType = 4
		case "array":
			castType = 5
		case "object":
			castType = 6
		case "unset":
			castType = 7
		default:
			return fmt.Errorf("unknown cast type: %s", node.Type)
		}

		// Emit CAST instruction
		c.EmitWithExtended(vm.OpCast, uint32(node.Token.Pos.Line),
			castType,
			vm.TmpVarOperand(0),
			vm.UnusedOperand(),
			vm.TmpVarOperand(1)) // Result in temp 1
		return nil

	// Instanceof
	case *ast.InstanceofExpression:
		// Compile the left side (object)
		if err := c.Compile(node.Left); err != nil {
			return err
		}
		objTemp := vm.TmpVarOperand(0)

		// Compile the right side (class name/expression)
		if err := c.Compile(node.Right); err != nil {
			return err
		}
		classTemp := vm.TmpVarOperand(1)

		// Emit INSTANCEOF instruction
		c.EmitWithLine(vm.OpInstanceof, uint32(node.Token.Pos.Line),
			objTemp,
			classTemp,
			vm.TmpVarOperand(2)) // Result in temp 2
		return nil

	// New Expression (object instantiation)
	case *ast.NewExpression:
		// Compile class name
		if err := c.Compile(node.Class); err != nil {
			return err
		}
		classTemp := vm.TmpVarOperand(0)

		// Compile constructor arguments
		for _, arg := range node.Arguments {
			if err := c.Compile(arg); err != nil {
				return err
			}
			// TODO: Push arguments onto stack properly
		}

		// NEW instruction with argument count in extended value
		c.EmitWithExtended(vm.OpNew, uint32(node.Token.Pos.Line),
			uint32(len(node.Arguments)),
			classTemp,
			vm.UnusedOperand(),
			vm.TmpVarOperand(1)) // New object in temp 1
		return nil

	// ========================================
	// Control Flow Statements
	// ========================================

	// If Statement
	case *ast.IfStatement:
		// Compile condition
		if err := c.Compile(node.Condition); err != nil {
			return err
		}

		// JMPZ to alternative/end if condition is false
		jmpzPos := c.EmitWithLine(vm.OpJmpZ, uint32(node.Token.Pos.Line),
			vm.TmpVarOperand(0),
			vm.UnusedOperand(),
			vm.UnusedOperand())

		// Compile consequence block
		if err := c.Compile(node.Consequence); err != nil {
			return err
		}

		// JMP to end (skip elseif/else)
		jmpEndPos := c.EmitWithLine(vm.OpJmp, uint32(node.Token.Pos.Line),
			vm.UnusedOperand(),
			vm.UnusedOperand(),
			vm.UnusedOperand())

		// Patch JMPZ to point here
		altStart := c.CurrentPosition()
		c.ChangeOperand(jmpzPos, 1, vm.ConstOperand(uint32(altStart)))

		// Track positions for elseif jumps
		elseifJumps := []int{}

		// Compile elseif clauses
		for _, elseif := range node.ElseIfs {
			// Compile elseif condition
			if err := c.Compile(elseif.Condition); err != nil {
				return err
			}

			// JMPZ to next elseif/else
			elseifJmpz := c.EmitWithLine(vm.OpJmpZ, uint32(elseif.Token.Pos.Line),
				vm.TmpVarOperand(0),
				vm.UnusedOperand(),
				vm.UnusedOperand())

			// Compile elseif consequence
			if err := c.Compile(elseif.Consequence); err != nil {
				return err
			}

			// JMP to end
			elseifJmpEnd := c.EmitWithLine(vm.OpJmp, uint32(elseif.Token.Pos.Line),
				vm.UnusedOperand(),
				vm.UnusedOperand(),
				vm.UnusedOperand())
			elseifJumps = append(elseifJumps, elseifJmpEnd)

			// Patch JMPZ to next clause
			nextClause := c.CurrentPosition()
			c.ChangeOperand(elseifJmpz, 1, vm.ConstOperand(uint32(nextClause)))
		}

		// Compile alternative (else) if present
		if node.Alternative != nil {
			if err := c.Compile(node.Alternative); err != nil {
				return err
			}
		}

		// Patch all jumps to end
		endPos := c.CurrentPosition()
		c.ChangeOperand(jmpEndPos, 1, vm.ConstOperand(uint32(endPos)))
		for _, jmp := range elseifJumps {
			c.ChangeOperand(jmp, 1, vm.ConstOperand(uint32(endPos)))
		}
		return nil

	// While Loop
	case *ast.WhileStatement:
		// Remember start position for continue
		startPos := c.CurrentPosition()
		c.EnterLoop(startPos)

		// Compile condition
		if err := c.Compile(node.Condition); err != nil {
			return err
		}

		// JMPZ to end if condition is false
		jmpzPos := c.EmitWithLine(vm.OpJmpZ, uint32(node.Token.Pos.Line),
			vm.TmpVarOperand(0),
			vm.UnusedOperand(),
			vm.UnusedOperand())

		// Compile loop body
		if err := c.Compile(node.Body); err != nil {
			return err
		}

		// JMP back to start
		c.EmitWithLine(vm.OpJmp, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(startPos)),
			vm.UnusedOperand(),
			vm.UnusedOperand())

		// Patch JMPZ to jump here (end of loop)
		endPos := c.CurrentPosition()
		c.ChangeOperand(jmpzPos, 1, vm.ConstOperand(uint32(endPos)))

		// Exit loop and patch break/continue
		c.ExitLoop(endPos)
		return nil

	// For Loop
	case *ast.ForStatement:
		// Compile initialization expressions
		for _, init := range node.Init {
			if err := c.Compile(init); err != nil {
				return err
			}
			// Free the result
			c.Emit(vm.OpFree, vm.TmpVarOperand(0))
		}

		// Remember condition start position
		condStart := c.CurrentPosition()
		c.EnterLoop(condStart)

		// Compile condition (if any)
		var jmpzPos int
		if len(node.Condition) > 0 {
			// Evaluate all conditions with AND logic
			for i, cond := range node.Condition {
				if err := c.Compile(cond); err != nil {
					return err
				}
				if i < len(node.Condition)-1 {
					// Not the last condition, short-circuit if false
					jmpz := c.EmitWithLine(vm.OpJmpZ, uint32(node.Token.Pos.Line),
						vm.TmpVarOperand(0),
						vm.UnusedOperand(),
						vm.UnusedOperand())
					if i == 0 {
						jmpzPos = jmpz
					}
				}
			}
			// Final JMPZ to exit loop
			finalJmpz := c.EmitWithLine(vm.OpJmpZ, uint32(node.Token.Pos.Line),
				vm.TmpVarOperand(0),
				vm.UnusedOperand(),
				vm.UnusedOperand())
			if len(node.Condition) == 1 {
				jmpzPos = finalJmpz
			}
		}

		// Compile loop body
		if err := c.Compile(node.Body); err != nil {
			return err
		}

		// Remember increment position for continue
		incrementPos := c.CurrentPosition()

		// Compile increment expressions
		for _, inc := range node.Increment {
			if err := c.Compile(inc); err != nil {
				return err
			}
			// Free the result
			c.Emit(vm.OpFree, vm.TmpVarOperand(0))
		}

		// JMP back to condition
		c.EmitWithLine(vm.OpJmp, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(condStart)),
			vm.UnusedOperand(),
			vm.UnusedOperand())

		// Patch condition JMPZ to jump here (end of loop)
		endPos := c.CurrentPosition()
		if len(node.Condition) > 0 {
			c.ChangeOperand(jmpzPos, 1, vm.ConstOperand(uint32(endPos)))
		}

		// Update loop context to use increment position for continue
		if loop := c.CurrentLoop(); loop != nil {
			loop.startPos = incrementPos
		}

		// Exit loop and patch break/continue
		c.ExitLoop(endPos)
		return nil

	// Foreach Loop
	case *ast.ForeachStatement:
		// Compile array expression
		if err := c.Compile(node.Array); err != nil {
			return err
		}
		arrayTemp := vm.TmpVarOperand(0)

		// Choose reset opcode based on by-ref
		resetOp := vm.OpFeResetR
		fetchOp := vm.OpFeFetchR
		if node.ByRef {
			resetOp = vm.OpFeResetRW
			fetchOp = vm.OpFeFetchRW
		}

		// FE_RESET: Initialize foreach iterator
		c.EmitWithLine(resetOp, uint32(node.Token.Pos.Line),
			arrayTemp,
			vm.UnusedOperand(),
			vm.TmpVarOperand(1)) // Iterator in temp 1

		// Remember start position for continue
		startPos := c.CurrentPosition()
		c.EnterLoop(startPos)

		// FE_FETCH: Fetch next element (jumps to end if done)
		jmpEndPos := c.EmitWithLine(fetchOp, uint32(node.Token.Pos.Line),
			vm.TmpVarOperand(1), // Iterator
			vm.UnusedOperand(),
			vm.TmpVarOperand(2)) // Fetched value

		// Assign key if present
		if node.Key != nil {
			if keyVar, ok := node.Key.(*ast.Variable); ok {
				symbol, ok := c.ResolveVariable(keyVar.Name)
				if !ok {
					symbol = c.DefineVariable(keyVar.Name)
				}
				// Assign key (stored in temp 3 by FE_FETCH)
				c.EmitWithLine(vm.OpAssign, uint32(node.Token.Pos.Line),
					vm.TmpVarOperand(3),
					vm.UnusedOperand(),
					vm.CVOperand(uint32(symbol.Index)))
			}
		}

		// Assign value
		if valueVar, ok := node.Value.(*ast.Variable); ok {
			symbol, ok := c.ResolveVariable(valueVar.Name)
			if !ok {
				symbol = c.DefineVariable(valueVar.Name)
			}
			// Assign value (in temp 2)
			c.EmitWithLine(vm.OpAssign, uint32(node.Token.Pos.Line),
				vm.TmpVarOperand(2),
				vm.UnusedOperand(),
				vm.CVOperand(uint32(symbol.Index)))
		}

		// Compile loop body
		if err := c.Compile(node.Body); err != nil {
			return err
		}

		// JMP back to FE_FETCH
		c.EmitWithLine(vm.OpJmp, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(startPos)),
			vm.UnusedOperand(),
			vm.UnusedOperand())

		// End position
		endPos := c.CurrentPosition()

		// Patch FE_FETCH jump
		c.ChangeOperand(jmpEndPos, 1, vm.ConstOperand(uint32(endPos)))

		// FE_FREE: Clean up iterator
		c.EmitWithLine(vm.OpFeFree, uint32(node.Token.Pos.Line),
			vm.TmpVarOperand(1),
			vm.UnusedOperand(),
			vm.UnusedOperand())

		// Exit loop and patch break/continue
		c.ExitLoop(endPos)
		return nil

	// Break Statement
	case *ast.BreakStatement:
		if !c.InLoop() {
			return fmt.Errorf("break statement outside of loop")
		}

		// Emit JMP with placeholder (will be patched by ExitLoop)
		jmpPos := c.EmitWithLine(vm.OpJmp, uint32(node.Token.Pos.Line),
			vm.UnusedOperand(),
			vm.UnusedOperand(),
			vm.UnusedOperand())

		// Add to current loop's break jumps
		loop := c.CurrentLoop()
		loop.breakJumps = append(loop.breakJumps, jmpPos)
		return nil

	// Continue Statement
	case *ast.ContinueStatement:
		if !c.InLoop() {
			return fmt.Errorf("continue statement outside of loop")
		}

		// Emit JMP with placeholder (will be patched by ExitLoop)
		jmpPos := c.EmitWithLine(vm.OpJmp, uint32(node.Token.Pos.Line),
			vm.UnusedOperand(),
			vm.UnusedOperand(),
			vm.UnusedOperand())

		// Add to current loop's continue jumps
		loop := c.CurrentLoop()
		loop.continueJumps = append(loop.continueJumps, jmpPos)
		return nil

	// Switch Statement
	case *ast.SwitchStatement:
		// Compile switch subject
		if err := c.Compile(node.Subject); err != nil {
			return err
		}
		subjectTemp := vm.TmpVarOperand(0)

		// Track case jump positions
		caseJumps := []int{}
		var defaultCase *ast.SwitchCase

		// Enter switch as a loop context (for break)
		c.EnterLoop(c.CurrentPosition())

		// Compile each case
		for _, switchCase := range node.Cases {
			if switchCase.Value == nil {
				// Default case
				defaultCase = switchCase
				continue
			}

			// Compile case value
			if err := c.Compile(switchCase.Value); err != nil {
				return err
			}
			caseValueTemp := vm.TmpVarOperand(1)

			// Compare subject == case value
			c.EmitWithLine(vm.OpIsEqual, uint32(switchCase.Token.Pos.Line),
				subjectTemp,
				caseValueTemp,
				vm.TmpVarOperand(2)) // Result in temp 2

			// JMPNZ to case body if equal
			jmpCase := c.EmitWithLine(vm.OpJmpNZ, uint32(switchCase.Token.Pos.Line),
				vm.TmpVarOperand(2),
				vm.UnusedOperand(),
				vm.UnusedOperand())
			caseJumps = append(caseJumps, jmpCase)
		}

		// If no match, jump to default or end
		jmpDefault := c.EmitWithLine(vm.OpJmp, uint32(node.Token.Pos.Line),
			vm.UnusedOperand(),
			vm.UnusedOperand(),
			vm.UnusedOperand())

		// Compile case bodies
		for i, switchCase := range node.Cases {
			if switchCase.Value == nil {
				continue // Skip default, compile it later
			}

			// Patch jump to this case
			caseBodyPos := c.CurrentPosition()
			c.ChangeOperand(caseJumps[i], 1, vm.ConstOperand(uint32(caseBodyPos)))

			// Compile case statements
			for _, stmt := range switchCase.Body {
				if err := c.Compile(stmt); err != nil {
					return err
				}
			}
			// Note: PHP switch has fall-through by default, no automatic jump to end
		}

		// Compile default case if present
		if defaultCase != nil {
			defaultBodyPos := c.CurrentPosition()
			c.ChangeOperand(jmpDefault, 1, vm.ConstOperand(uint32(defaultBodyPos)))

			for _, stmt := range defaultCase.Body {
				if err := c.Compile(stmt); err != nil {
					return err
				}
			}
		} else {
			// No default case, patch jump to end
			endPos := c.CurrentPosition()
			c.ChangeOperand(jmpDefault, 1, vm.ConstOperand(uint32(endPos)))
		}

		// End of switch
		endPos := c.CurrentPosition()
		c.ExitLoop(endPos)
		return nil

	// Try-Catch-Finally Statement
	case *ast.TryStatement:
		// For now, implement simplified version
		// Full exception handling requires VM support

		// Use FAST_CALL for finally block if present
		var fastCallPos int
		if node.Finally != nil {
			fastCallPos = c.EmitWithLine(vm.OpFastCall, uint32(node.Token.Pos.Line),
				vm.UnusedOperand(),
				vm.UnusedOperand(),
				vm.UnusedOperand())
		}

		// Compile try block
		if err := c.Compile(node.Body); err != nil {
			return err
		}

		// JMP over catch blocks
		jmpEndPos := c.EmitWithLine(vm.OpJmp, uint32(node.Token.Pos.Line),
			vm.UnusedOperand(),
			vm.UnusedOperand(),
			vm.UnusedOperand())

		// Compile catch clauses
		for _, catchClause := range node.CatchClauses {
			// CATCH opcode
			c.EmitWithLine(vm.OpCatch, uint32(catchClause.Token.Pos.Line),
				vm.UnusedOperand(),
				vm.UnusedOperand(),
				vm.TmpVarOperand(0)) // Exception in temp 0

			// Assign exception to variable
			if catchClause.Variable != nil {
				symbol, ok := c.ResolveVariable(catchClause.Variable.Name)
				if !ok {
					symbol = c.DefineVariable(catchClause.Variable.Name)
				}
				c.EmitWithLine(vm.OpAssign, uint32(catchClause.Token.Pos.Line),
					vm.TmpVarOperand(0),
					vm.UnusedOperand(),
					vm.CVOperand(uint32(symbol.Index)))
			}

			// Compile catch block
			if err := c.Compile(catchClause.Body); err != nil {
				return err
			}

			// JMP to finally/end
			c.EmitWithLine(vm.OpJmp, uint32(catchClause.Token.Pos.Line),
				vm.UnusedOperand(),
				vm.UnusedOperand(),
				vm.UnusedOperand())
		}

		// End position
		endPos := c.CurrentPosition()
		c.ChangeOperand(jmpEndPos, 1, vm.ConstOperand(uint32(endPos)))

		// Compile finally block if present
		if node.Finally != nil {
			finallyPos := c.CurrentPosition()
			c.ChangeOperand(fastCallPos, 1, vm.ConstOperand(uint32(finallyPos)))

			if err := c.Compile(node.Finally); err != nil {
				return err
			}

			// FAST_RET to return from finally
			c.EmitWithLine(vm.OpFastRet, uint32(node.Token.Pos.Line),
				vm.UnusedOperand(),
				vm.UnusedOperand(),
				vm.UnusedOperand())
		}
		return nil

	// Throw Statement
	case *ast.ThrowStatement:
		// Compile exception expression
		if err := c.Compile(node.Expression); err != nil {
			return err
		}

		// THROW instruction
		c.EmitWithLine(vm.OpThrow, uint32(node.Token.Pos.Line),
			vm.TmpVarOperand(0),
			vm.UnusedOperand(),
			vm.UnusedOperand())
		return nil

	// ========================================
	// Function and Class Declarations
	// ========================================

	// Function Declaration
	case *ast.FunctionDeclaration:
		// Store function name as constant
		funcNameIdx := c.AddConstant(node.Name.Value)

		// Remember function start position
		funcStart := c.CurrentPosition()

		// Enter new scope for function
		c.EnterScope()

		// Emit RECV opcodes for each parameter
		for i, param := range node.Parameters {
			// Define parameter variable in function scope
			symbol := c.DefineVariable(param.Name.Name)

			if param.Variadic {
				// RECV_VARIADIC for ...args
				c.EmitWithLine(vm.OpRecvVariadic, uint32(node.Token.Pos.Line),
					vm.ConstOperand(uint32(i)), // Parameter index
					vm.UnusedOperand(),
					vm.CVOperand(uint32(symbol.Index))) // Store in compiled variable
			} else if param.DefaultValue != nil {
				// RECV_INIT for parameters with defaults
				// Compile default value
				if err := c.Compile(param.DefaultValue); err != nil {
					return err
				}

				c.EmitWithLine(vm.OpRecvInit, uint32(node.Token.Pos.Line),
					vm.ConstOperand(uint32(i)),    // Parameter index
					vm.TmpVarOperand(0),           // Default value in temp 0
					vm.CVOperand(uint32(symbol.Index))) // Store in compiled variable
			} else {
				// RECV for required parameters
				recvOp := vm.OpRecv
				if param.ByRef {
					recvOp = vm.OpSendRef // Use SEND_REF for by-reference parameters
				}

				c.EmitWithLine(recvOp, uint32(node.Token.Pos.Line),
					vm.ConstOperand(uint32(i)),    // Parameter index
					vm.UnusedOperand(),
					vm.CVOperand(uint32(symbol.Index))) // Store in compiled variable
			}
		}

		// Compile function body
		if err := c.Compile(node.Body); err != nil {
			return err
		}

		// Add implicit return if function doesn't end with return
		if !c.LastInstructionIs(vm.OpReturn) && !c.LastInstructionIs(vm.OpReturnByRef) {
			// Return null
			c.EmitWithLine(vm.OpReturn, uint32(node.Token.Pos.Line),
				vm.UnusedOperand(),
				vm.UnusedOperand(),
				vm.UnusedOperand())
		}

		// Exit function scope
		c.ExitScope()

		// Function end position
		funcEnd := c.CurrentPosition()

		// DECLARE_FUNCTION to register the function
		// Store function metadata: name index, start pos, end pos, num params
		c.EmitWithExtended(vm.OpDeclareFunction, uint32(node.Token.Pos.Line),
			uint32(len(node.Parameters)), // Number of parameters
			vm.ConstOperand(uint32(funcNameIdx)), // Function name
			vm.ConstOperand(uint32(funcStart)),   // Function start position
			vm.ConstOperand(uint32(funcEnd)))     // Function end position

		return nil

	default:
		return fmt.Errorf("compilation not yet implemented for node type: %T", node)
	}
}

// ========================================
// Helper Methods
// ========================================

// Instructions returns the current instruction list
func (c *Compiler) Instructions() vm.Instructions {
	return c.instructions
}

// Reset resets the compiler state for a new compilation
func (c *Compiler) Reset() {
	c.instructions = vm.Instructions{}
	c.constants = []interface{}{}
	c.constantMap = make(map[interface{}]int)
	c.lastInstruction = EmittedInstruction{}
	c.previousInstruction = EmittedInstruction{}
	c.loopStack = []*LoopContext{}
	c.InitSymbolTable()
}

// ========================================
// Loop Context Management
// ========================================

// EnterLoop pushes a new loop context onto the stack
func (c *Compiler) EnterLoop(startPos int) {
	c.loopStack = append(c.loopStack, &LoopContext{
		startPos:      startPos,
		breakJumps:    []int{},
		continueJumps: []int{},
	})
}

// ExitLoop pops a loop context and patches all break/continue jumps
func (c *Compiler) ExitLoop(endPos int) {
	if len(c.loopStack) == 0 {
		return
	}

	loop := c.loopStack[len(c.loopStack)-1]
	c.loopStack = c.loopStack[:len(c.loopStack)-1]

	// Patch all break jumps to jump to end
	for _, pos := range loop.breakJumps {
		c.ChangeOperand(pos, 1, vm.ConstOperand(uint32(endPos)))
	}

	// Patch all continue jumps to jump to start
	for _, pos := range loop.continueJumps {
		c.ChangeOperand(pos, 1, vm.ConstOperand(uint32(loop.startPos)))
	}
}

// CurrentLoop returns the current loop context (nil if not in a loop)
func (c *Compiler) CurrentLoop() *LoopContext {
	if len(c.loopStack) == 0 {
		return nil
	}
	return c.loopStack[len(c.loopStack)-1]
}

// InLoop returns true if currently inside a loop
func (c *Compiler) InLoop() bool {
	return len(c.loopStack) > 0
}
