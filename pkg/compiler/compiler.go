package compiler

import (
	"fmt"

	"github.com/krizos/php-go/pkg/ast"
	"github.com/krizos/php-go/pkg/vm"
)

// Compiler compiles PHP AST into VM bytecode
type Compiler struct {
	// instructions holds the generated bytecode
	instructions vm.Instructions

	// constants holds literal values referenced by the bytecode
	constants []interface{}

	// constantMap maps constant values to their indices for deduplication
	constantMap map[interface{}]int

	// symbolTable manages variable scopes
	symbolTable *SymbolTable

	// lastInstruction tracks the most recently emitted instruction
	lastInstruction EmittedInstruction

	// previousInstruction tracks the instruction before lastInstruction
	previousInstruction EmittedInstruction
}

// EmittedInstruction tracks metadata about an emitted instruction
type EmittedInstruction struct {
	Opcode   vm.Opcode
	Position int
}

// New creates a new compiler instance
func New() *Compiler {
	c := &Compiler{
		instructions:        vm.Instructions{},
		constants:           []interface{}{},
		constantMap:         make(map[interface{}]int),
		lastInstruction:     EmittedInstruction{},
		previousInstruction: EmittedInstruction{},
	}
	c.InitSymbolTable()
	return c
}

// ========================================
// Constant Table Management
// ========================================

// AddConstant adds a constant to the constant table
// Returns the index of the constant (reuses existing if duplicate)
func (c *Compiler) AddConstant(value interface{}) int {
	// Check if constant already exists
	if idx, ok := c.constantMap[value]; ok {
		return idx
	}

	// Add new constant
	idx := len(c.constants)
	c.constants = append(c.constants, value)
	c.constantMap[value] = idx
	return idx
}

// GetConstant retrieves a constant by index
func (c *Compiler) GetConstant(idx int) (interface{}, error) {
	if idx < 0 || idx >= len(c.constants) {
		return nil, fmt.Errorf("constant index out of bounds: %d", idx)
	}
	return c.constants[idx], nil
}

// Constants returns a copy of the constant table
func (c *Compiler) Constants() []interface{} {
	result := make([]interface{}, len(c.constants))
	copy(result, c.constants)
	return result
}

// ========================================
// Opcode Emission
// ========================================

// Emit emits an instruction with the given opcode and operands
// Returns the position of the emitted instruction
func (c *Compiler) Emit(opcode vm.Opcode, operands ...vm.Operand) int {
	return c.EmitWithLine(opcode, 0, operands...)
}

// EmitWithLine emits an instruction with line number information
// Returns the position of the emitted instruction
func (c *Compiler) EmitWithLine(opcode vm.Opcode, lineno uint32, operands ...vm.Operand) int {
	instr := vm.Instruction{
		Opcode: opcode,
		Lineno: lineno,
	}

	// Set operands based on count
	if len(operands) > 0 {
		instr.Op1 = operands[0]
	}
	if len(operands) > 1 {
		instr.Op2 = operands[1]
	}
	if len(operands) > 2 {
		instr.Result = operands[2]
	}

	pos := c.addInstruction(instr)

	// Update instruction tracking
	c.previousInstruction = c.lastInstruction
	c.lastInstruction = EmittedInstruction{
		Opcode:   opcode,
		Position: pos,
	}

	return pos
}

// EmitWithExtended emits an instruction with an extended value
func (c *Compiler) EmitWithExtended(opcode vm.Opcode, lineno uint32, extended uint32, operands ...vm.Operand) int {
	instr := vm.Instruction{
		Opcode:        opcode,
		Lineno:        lineno,
		ExtendedValue: extended,
	}

	// Set operands based on count
	if len(operands) > 0 {
		instr.Op1 = operands[0]
	}
	if len(operands) > 1 {
		instr.Op2 = operands[1]
	}
	if len(operands) > 2 {
		instr.Result = operands[2]
	}

	pos := c.addInstruction(instr)

	// Update instruction tracking
	c.previousInstruction = c.lastInstruction
	c.lastInstruction = EmittedInstruction{
		Opcode:   opcode,
		Position: pos,
	}

	return pos
}

// addInstruction adds an instruction to the instruction list
func (c *Compiler) addInstruction(instr vm.Instruction) int {
	pos := len(c.instructions)
	c.instructions = append(c.instructions, instr)
	return pos
}

// ========================================
// Instruction Manipulation
// ========================================

// ReplaceInstruction replaces the instruction at the given position
func (c *Compiler) ReplaceInstruction(pos int, instr vm.Instruction) error {
	if pos < 0 || pos >= len(c.instructions) {
		return fmt.Errorf("instruction position out of bounds: %d", pos)
	}
	c.instructions[pos] = instr
	return nil
}

// ChangeOperand changes an operand in an instruction at the given position
func (c *Compiler) ChangeOperand(pos int, operandNum int, operand vm.Operand) error {
	if pos < 0 || pos >= len(c.instructions) {
		return fmt.Errorf("instruction position out of bounds: %d", pos)
	}

	instr := c.instructions[pos]
	switch operandNum {
	case 1:
		instr.Op1 = operand
	case 2:
		instr.Op2 = operand
	case 3:
		instr.Result = operand
	default:
		return fmt.Errorf("invalid operand number: %d (must be 1, 2, or 3)", operandNum)
	}

	c.instructions[pos] = instr
	return nil
}

// CurrentPosition returns the position where the next instruction will be emitted
func (c *Compiler) CurrentPosition() int {
	return len(c.instructions)
}

// LastInstructionIs checks if the last instruction is the given opcode
func (c *Compiler) LastInstructionIs(opcode vm.Opcode) bool {
	return c.lastInstruction.Opcode == opcode
}

// RemoveLastInstruction removes the last emitted instruction
// Used for optimizations (e.g., removing unnecessary OpPop)
func (c *Compiler) RemoveLastInstruction() {
	if len(c.instructions) == 0 {
		return
	}

	c.instructions = c.instructions[:c.lastInstruction.Position]
	c.lastInstruction = c.previousInstruction
}

// ========================================
// Program Assembly
// ========================================

// Bytecode represents the compiled bytecode program
type Bytecode struct {
	Instructions vm.Instructions
	Constants    []interface{}
}

// Bytecode assembles and returns the final compiled bytecode
func (c *Compiler) Bytecode() *Bytecode {
	return &Bytecode{
		Instructions: c.instructions,
		Constants:    c.constants,
	}
}

// ========================================
// Compilation Entry Point
// ========================================

// Compile compiles an AST program into bytecode
func (c *Compiler) Compile(node ast.Node) error {
	switch node := node.(type) {
	case *ast.Program:
		for _, stmt := range node.Statements {
			if err := c.Compile(stmt); err != nil {
				return err
			}
		}
		return nil

	// Statements
	case *ast.ExpressionStatement:
		if err := c.Compile(node.Expression); err != nil {
			return err
		}
		// Pop the result since expression statements don't use their value
		c.Emit(vm.OpFree, vm.TmpVarOperand(0)) // TODO: track temp var numbers properly
		return nil

	case *ast.BlockStatement:
		for _, stmt := range node.Statements {
			if err := c.Compile(stmt); err != nil {
				return err
			}
		}
		return nil

	case *ast.EchoStatement:
		for _, expr := range node.Expressions {
			if err := c.Compile(expr); err != nil {
				return err
			}
			// Emit ECHO instruction for each expression
			c.EmitWithLine(vm.OpEcho, uint32(node.Token.Pos.Line), vm.TmpVarOperand(0))
		}
		return nil

	case *ast.ReturnStatement:
		if node.ReturnValue != nil {
			if err := c.Compile(node.ReturnValue); err != nil {
				return err
			}
			c.EmitWithLine(vm.OpReturn, uint32(node.Token.Pos.Line), vm.TmpVarOperand(0))
		} else {
			// Return null
			c.EmitWithLine(vm.OpReturn, uint32(node.Token.Pos.Line))
		}
		return nil

	// Literals
	case *ast.IntegerLiteral:
		constIdx := c.AddConstant(node.Value)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	case *ast.FloatLiteral:
		constIdx := c.AddConstant(node.Value)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	case *ast.StringLiteral:
		constIdx := c.AddConstant(node.Value)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	case *ast.BooleanLiteral:
		constIdx := c.AddConstant(node.Value)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	case *ast.NullLiteral:
		constIdx := c.AddConstant(nil)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	// Infix Expressions (binary operators)
	case *ast.InfixExpression:
		// Compile left operand
		if err := c.Compile(node.Left); err != nil {
			return err
		}
		leftTemp := vm.TmpVarOperand(0) // TODO: proper temp tracking

		// Compile right operand
		if err := c.Compile(node.Right); err != nil {
			return err
		}
		rightTemp := vm.TmpVarOperand(1) // TODO: proper temp tracking

		// Emit the appropriate opcode based on operator
		var opcode vm.Opcode
		switch node.Operator {
		case "+":
			opcode = vm.OpAdd
		case "-":
			opcode = vm.OpSub
		case "*":
			opcode = vm.OpMul
		case "/":
			opcode = vm.OpDiv
		case "%":
			opcode = vm.OpMod
		case "**":
			opcode = vm.OpPow
		case ".":
			opcode = vm.OpConcat
		case "==":
			opcode = vm.OpIsEqual
		case "!=":
			opcode = vm.OpIsNotEqual
		case "===":
			opcode = vm.OpIsIdentical
		case "!==":
			opcode = vm.OpIsNotIdentical
		case "<":
			opcode = vm.OpIsSmaller
		case "<=":
			opcode = vm.OpIsSmallerOrEqual
		case ">":
			// Swap operands and use IS_SMALLER
			opcode = vm.OpIsSmaller
			leftTemp, rightTemp = rightTemp, leftTemp
		case ">=":
			// Swap operands and use IS_SMALLER_OR_EQUAL
			opcode = vm.OpIsSmallerOrEqual
			leftTemp, rightTemp = rightTemp, leftTemp
		case "|":
			opcode = vm.OpBWOr
		case "&":
			opcode = vm.OpBWAnd
		case "^":
			opcode = vm.OpBWXor
		case "<<":
			opcode = vm.OpSL
		case ">>":
			opcode = vm.OpSR
		case "<=>":
			opcode = vm.OpSpaceship
		default:
			return fmt.Errorf("unknown infix operator: %s", node.Operator)
		}

		c.EmitWithLine(opcode, uint32(node.Token.Pos.Line),
			leftTemp,
			rightTemp,
			vm.TmpVarOperand(2)) // Result in temp 2
		return nil

	// Prefix Expressions (unary operators)
	case *ast.PrefixExpression:
		// Compile operand
		if err := c.Compile(node.Right); err != nil {
			return err
		}

		// Emit the appropriate opcode
		var opcode vm.Opcode
		switch node.Operator {
		case "!":
			opcode = vm.OpBoolNot
		case "-":
			// Unary minus: 0 - operand
			constIdx := c.AddConstant(int64(0))
			c.EmitWithLine(vm.OpSub, uint32(node.Token.Pos.Line),
				vm.ConstOperand(uint32(constIdx)),
				vm.TmpVarOperand(0),
				vm.TmpVarOperand(1))
			return nil
		case "~":
			opcode = vm.OpBWNot
		default:
			return fmt.Errorf("unknown prefix operator: %s", node.Operator)
		}

		c.EmitWithLine(opcode, uint32(node.Token.Pos.Line),
			vm.TmpVarOperand(0),
			vm.UnusedOperand(),
			vm.TmpVarOperand(1))
		return nil

	case *ast.Variable:
		// Look up the variable in the symbol table
		symbol, ok := c.ResolveVariable(node.Name)
		if !ok {
			// Variable not defined, define it now (PHP allows implicit declaration)
			symbol = c.DefineVariable(node.Name)
		}

		// Emit FETCH instruction based on scope
		switch symbol.Scope {
		case GlobalScope:
			// Fetch global variable
			c.EmitWithLine(vm.OpFetchR, uint32(node.Token.Pos.Line),
				vm.CVOperand(uint32(symbol.Index)),
				vm.UnusedOperand(),
				vm.TmpVarOperand(0))
		case LocalScope:
			// Fetch local variable (compiled variable for direct access)
			c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
				vm.CVOperand(uint32(symbol.Index)),
				vm.UnusedOperand(),
				vm.TmpVarOperand(0))
		case BuiltinScope:
			return fmt.Errorf("cannot use builtin '%s' as variable", node.Name)
		case FreeScope:
			// Fetch free variable (closure variable)
			c.EmitWithLine(vm.OpFetchR, uint32(node.Token.Pos.Line),
				vm.CVOperand(uint32(symbol.Index)),
				vm.UnusedOperand(),
				vm.TmpVarOperand(0))
		}
		return nil

	case *ast.AssignmentExpression:
		// Compile the right side first
		if err := c.Compile(node.Right); err != nil {
			return err
		}

		// Handle the left side (variable)
		if variable, ok := node.Left.(*ast.Variable); ok {
			// Look up or define the variable
			symbol, ok := c.ResolveVariable(variable.Name)
			if !ok {
				symbol = c.DefineVariable(variable.Name)
			}

			// Emit ASSIGN instruction
			c.EmitWithLine(vm.OpAssign, uint32(node.Token.Pos.Line),
				vm.TmpVarOperand(0), // Value is in temp var 0
				vm.UnusedOperand(),
				vm.CVOperand(uint32(symbol.Index))) // Store in compiled variable
			return nil
		}

		return fmt.Errorf("assignment to non-variable not yet implemented")

	// Identifier (convert to string constant)
	case *ast.Identifier:
		constIdx := c.AddConstant(node.Value)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	// Grouped Expression (just compile the inner expression)
	case *ast.GroupedExpression:
		return c.Compile(node.Expr)

	// Array Literal
	case *ast.ArrayExpression:
		// Initialize empty array
		c.EmitWithLine(vm.OpInitArray, uint32(node.Token.Pos.Line),
			vm.UnusedOperand(),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0)) // Array in temp var 0

		// Add elements to array
		for _, elem := range node.Elements {
			// Compile the value
			if err := c.Compile(elem.Value); err != nil {
				return err
			}
			valueTemp := vm.TmpVarOperand(1) // Value in temp 1

			// If there's a key, compile it
			if elem.Key != nil {
				if err := c.Compile(elem.Key); err != nil {
					return err
				}
				keyTemp := vm.TmpVarOperand(2) // Key in temp 2

				// ADD_ARRAY_ELEMENT with key: array[key] = value
				c.EmitWithLine(vm.OpAddArrayElement, uint32(node.Token.Pos.Line),
					valueTemp,
					keyTemp,
					vm.TmpVarOperand(0)) // Result array in temp 0
			} else {
				// ADD_ARRAY_ELEMENT without key: array[] = value
				c.EmitWithLine(vm.OpAddArrayElement, uint32(node.Token.Pos.Line),
					valueTemp,
					vm.UnusedOperand(),
					vm.TmpVarOperand(0)) // Result array in temp 0
			}
		}
		return nil

	// Array Access
	case *ast.IndexExpression:
		// Compile the array/string
		if err := c.Compile(node.Left); err != nil {
			return err
		}
		arrayTemp := vm.TmpVarOperand(0)

		// Compile the index
		if err := c.Compile(node.Index); err != nil {
			return err
		}
		indexTemp := vm.TmpVarOperand(1)

		// Emit FETCH_DIM_R: result = array[index]
		c.EmitWithLine(vm.OpFetchDimR, uint32(node.Token.Pos.Line),
			arrayTemp,
			indexTemp,
			vm.TmpVarOperand(2)) // Result in temp 2
		return nil

	// Property Access
	case *ast.PropertyExpression:
		// Compile the object
		if err := c.Compile(node.Object); err != nil {
			return err
		}
		objTemp := vm.TmpVarOperand(0)

		// Compile the property (could be identifier or dynamic expression)
		if err := c.Compile(node.Property); err != nil {
			return err
		}
		propTemp := vm.TmpVarOperand(1)

		// Emit FETCH_OBJ_R: result = obj->prop
		c.EmitWithLine(vm.OpFetchObjR, uint32(node.Token.Pos.Line),
			objTemp,
			propTemp,
			vm.TmpVarOperand(2)) // Result in temp 2
		return nil

	// Function Call
	case *ast.CallExpression:
		// For now, we'll handle simple function calls by name
		// Full implementation with dynamic calls will come later

		// Compile arguments first
		for _, arg := range node.Arguments {
			if err := c.Compile(arg); err != nil {
				return err
			}
			// TODO: Push arguments onto stack properly
		}

		// Compile the function expression
		if err := c.Compile(node.Function); err != nil {
			return err
		}
		funcTemp := vm.TmpVarOperand(0)

		// Initialize function call
		c.EmitWithLine(vm.OpInitFcallByName, uint32(node.Token.Pos.Line),
			funcTemp,
			vm.ConstOperand(uint32(len(node.Arguments))), // Argument count
			vm.UnusedOperand())

		// Execute function call
		c.EmitWithLine(vm.OpDoFcall, uint32(node.Token.Pos.Line),
			vm.UnusedOperand(),
			vm.UnusedOperand(),
			vm.TmpVarOperand(1)) // Result in temp 1
		return nil

	// Method Call
	case *ast.MethodCallExpression:
		// Compile the object
		if err := c.Compile(node.Object); err != nil {
			return err
		}
		objTemp := vm.TmpVarOperand(0)

		// Compile the method name (could be identifier or dynamic)
		if err := c.Compile(node.Method); err != nil {
			return err
		}
		methodTemp := vm.TmpVarOperand(1)

		// Compile arguments
		for _, arg := range node.Arguments {
			if err := c.Compile(arg); err != nil {
				return err
			}
			// TODO: Push arguments onto stack properly
		}

		// Initialize method call
		c.EmitWithLine(vm.OpInitMethodCall, uint32(node.Token.Pos.Line),
			objTemp,
			methodTemp,
			vm.UnusedOperand())

		// Execute method call with argument count in extended value
		c.EmitWithExtended(vm.OpDoFcall, uint32(node.Token.Pos.Line),
			uint32(len(node.Arguments)),
			vm.UnusedOperand(),
			vm.UnusedOperand(),
			vm.TmpVarOperand(2)) // Result in temp 2
		return nil

	// Ternary Operator
	case *ast.TernaryExpression:
		// Compile the condition
		if err := c.Compile(node.Condition); err != nil {
			return err
		}

		// Short ternary form: $x ?: $y (if $x is falsy, use $y)
		if node.Consequence == nil {
			// Use JMP_SET: if (condition) { result = condition; goto end; }
			// Emit JMP_SET with placeholder address
			jmpSetPos := c.EmitWithLine(vm.OpJmpSet, uint32(node.Token.Pos.Line),
				vm.TmpVarOperand(0),
				vm.UnusedOperand(),
				vm.TmpVarOperand(1)) // Result in temp 1

			// Compile alternative (used if condition is falsy)
			if err := c.Compile(node.Alternative); err != nil {
				return err
			}
			// Move alternative to result
			c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
				vm.TmpVarOperand(0),
				vm.UnusedOperand(),
				vm.TmpVarOperand(1))

			// Patch JMP_SET to jump here
			endPos := c.CurrentPosition()
			c.ChangeOperand(jmpSetPos, 2, vm.ConstOperand(uint32(endPos)))
			return nil
		}

		// Full ternary form: $x ? $y : $z
		// JMPZ consequence_end with placeholder
		jmpzPos := c.EmitWithLine(vm.OpJmpZ, uint32(node.Token.Pos.Line),
			vm.TmpVarOperand(0),
			vm.UnusedOperand(),
			vm.UnusedOperand())

		// Compile consequence (true branch)
		if err := c.Compile(node.Consequence); err != nil {
			return err
		}
		// Move consequence to result
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.TmpVarOperand(0),
			vm.UnusedOperand(),
			vm.TmpVarOperand(1)) // Result in temp 1

		// JMP to end with placeholder
		jmpEndPos := c.EmitWithLine(vm.OpJmp, uint32(node.Token.Pos.Line),
			vm.UnusedOperand(),
			vm.UnusedOperand(),
			vm.UnusedOperand())

		// Patch JMPZ to jump to alternative
		altPos := c.CurrentPosition()
		c.ChangeOperand(jmpzPos, 1, vm.ConstOperand(uint32(altPos)))

		// Compile alternative (false branch)
		if err := c.Compile(node.Alternative); err != nil {
			return err
		}
		// Move alternative to result
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.TmpVarOperand(0),
			vm.UnusedOperand(),
			vm.TmpVarOperand(1))

		// Patch JMP to jump to end
		endPos := c.CurrentPosition()
		c.ChangeOperand(jmpEndPos, 1, vm.ConstOperand(uint32(endPos)))
		return nil

	// Type Cast
	case *ast.CastExpression:
		// Compile the expression to cast
		if err := c.Compile(node.Expr); err != nil {
			return err
		}

		// Map cast type to opcode extended value
		var castType uint32
		switch node.Type {
		case "int", "integer":
			castType = 1
		case "bool", "boolean":
			castType = 2
		case "float", "double", "real":
			castType = 3
		case "string":
			castType = 4
		case "array":
			castType = 5
		case "object":
			castType = 6
		case "unset":
			castType = 7
		default:
			return fmt.Errorf("unknown cast type: %s", node.Type)
		}

		// Emit CAST instruction
		c.EmitWithExtended(vm.OpCast, uint32(node.Token.Pos.Line),
			castType,
			vm.TmpVarOperand(0),
			vm.UnusedOperand(),
			vm.TmpVarOperand(1)) // Result in temp 1
		return nil

	// Instanceof
	case *ast.InstanceofExpression:
		// Compile the left side (object)
		if err := c.Compile(node.Left); err != nil {
			return err
		}
		objTemp := vm.TmpVarOperand(0)

		// Compile the right side (class name/expression)
		if err := c.Compile(node.Right); err != nil {
			return err
		}
		classTemp := vm.TmpVarOperand(1)

		// Emit INSTANCEOF instruction
		c.EmitWithLine(vm.OpInstanceof, uint32(node.Token.Pos.Line),
			objTemp,
			classTemp,
			vm.TmpVarOperand(2)) // Result in temp 2
		return nil

	default:
		return fmt.Errorf("compilation not yet implemented for node type: %T", node)
	}
}

// ========================================
// Helper Methods
// ========================================

// Instructions returns the current instruction list
func (c *Compiler) Instructions() vm.Instructions {
	return c.instructions
}

// Reset resets the compiler state for a new compilation
func (c *Compiler) Reset() {
	c.instructions = vm.Instructions{}
	c.constants = []interface{}{}
	c.constantMap = make(map[interface{}]int)
	c.lastInstruction = EmittedInstruction{}
	c.previousInstruction = EmittedInstruction{}
	c.InitSymbolTable()
}
