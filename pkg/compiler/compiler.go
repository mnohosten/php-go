package compiler

import (
	"fmt"

	"github.com/krizos/php-go/pkg/ast"
	"github.com/krizos/php-go/pkg/vm"
)

// Compiler compiles PHP AST into VM bytecode
type Compiler struct {
	// instructions holds the generated bytecode
	instructions vm.Instructions

	// constants holds literal values referenced by the bytecode
	constants []interface{}

	// constantMap maps constant values to their indices for deduplication
	constantMap map[interface{}]int

	// lastInstruction tracks the most recently emitted instruction
	lastInstruction EmittedInstruction

	// previousInstruction tracks the instruction before lastInstruction
	previousInstruction EmittedInstruction
}

// EmittedInstruction tracks metadata about an emitted instruction
type EmittedInstruction struct {
	Opcode   vm.Opcode
	Position int
}

// New creates a new compiler instance
func New() *Compiler {
	return &Compiler{
		instructions:        vm.Instructions{},
		constants:           []interface{}{},
		constantMap:         make(map[interface{}]int),
		lastInstruction:     EmittedInstruction{},
		previousInstruction: EmittedInstruction{},
	}
}

// ========================================
// Constant Table Management
// ========================================

// AddConstant adds a constant to the constant table
// Returns the index of the constant (reuses existing if duplicate)
func (c *Compiler) AddConstant(value interface{}) int {
	// Check if constant already exists
	if idx, ok := c.constantMap[value]; ok {
		return idx
	}

	// Add new constant
	idx := len(c.constants)
	c.constants = append(c.constants, value)
	c.constantMap[value] = idx
	return idx
}

// GetConstant retrieves a constant by index
func (c *Compiler) GetConstant(idx int) (interface{}, error) {
	if idx < 0 || idx >= len(c.constants) {
		return nil, fmt.Errorf("constant index out of bounds: %d", idx)
	}
	return c.constants[idx], nil
}

// Constants returns a copy of the constant table
func (c *Compiler) Constants() []interface{} {
	result := make([]interface{}, len(c.constants))
	copy(result, c.constants)
	return result
}

// ========================================
// Opcode Emission
// ========================================

// Emit emits an instruction with the given opcode and operands
// Returns the position of the emitted instruction
func (c *Compiler) Emit(opcode vm.Opcode, operands ...vm.Operand) int {
	return c.EmitWithLine(opcode, 0, operands...)
}

// EmitWithLine emits an instruction with line number information
// Returns the position of the emitted instruction
func (c *Compiler) EmitWithLine(opcode vm.Opcode, lineno uint32, operands ...vm.Operand) int {
	instr := vm.Instruction{
		Opcode: opcode,
		Lineno: lineno,
	}

	// Set operands based on count
	if len(operands) > 0 {
		instr.Op1 = operands[0]
	}
	if len(operands) > 1 {
		instr.Op2 = operands[1]
	}
	if len(operands) > 2 {
		instr.Result = operands[2]
	}

	pos := c.addInstruction(instr)

	// Update instruction tracking
	c.previousInstruction = c.lastInstruction
	c.lastInstruction = EmittedInstruction{
		Opcode:   opcode,
		Position: pos,
	}

	return pos
}

// EmitWithExtended emits an instruction with an extended value
func (c *Compiler) EmitWithExtended(opcode vm.Opcode, lineno uint32, extended uint32, operands ...vm.Operand) int {
	instr := vm.Instruction{
		Opcode:        opcode,
		Lineno:        lineno,
		ExtendedValue: extended,
	}

	// Set operands based on count
	if len(operands) > 0 {
		instr.Op1 = operands[0]
	}
	if len(operands) > 1 {
		instr.Op2 = operands[1]
	}
	if len(operands) > 2 {
		instr.Result = operands[2]
	}

	pos := c.addInstruction(instr)

	// Update instruction tracking
	c.previousInstruction = c.lastInstruction
	c.lastInstruction = EmittedInstruction{
		Opcode:   opcode,
		Position: pos,
	}

	return pos
}

// addInstruction adds an instruction to the instruction list
func (c *Compiler) addInstruction(instr vm.Instruction) int {
	pos := len(c.instructions)
	c.instructions = append(c.instructions, instr)
	return pos
}

// ========================================
// Instruction Manipulation
// ========================================

// ReplaceInstruction replaces the instruction at the given position
func (c *Compiler) ReplaceInstruction(pos int, instr vm.Instruction) error {
	if pos < 0 || pos >= len(c.instructions) {
		return fmt.Errorf("instruction position out of bounds: %d", pos)
	}
	c.instructions[pos] = instr
	return nil
}

// ChangeOperand changes an operand in an instruction at the given position
func (c *Compiler) ChangeOperand(pos int, operandNum int, operand vm.Operand) error {
	if pos < 0 || pos >= len(c.instructions) {
		return fmt.Errorf("instruction position out of bounds: %d", pos)
	}

	instr := c.instructions[pos]
	switch operandNum {
	case 1:
		instr.Op1 = operand
	case 2:
		instr.Op2 = operand
	case 3:
		instr.Result = operand
	default:
		return fmt.Errorf("invalid operand number: %d (must be 1, 2, or 3)", operandNum)
	}

	c.instructions[pos] = instr
	return nil
}

// CurrentPosition returns the position where the next instruction will be emitted
func (c *Compiler) CurrentPosition() int {
	return len(c.instructions)
}

// LastInstructionIs checks if the last instruction is the given opcode
func (c *Compiler) LastInstructionIs(opcode vm.Opcode) bool {
	return c.lastInstruction.Opcode == opcode
}

// RemoveLastInstruction removes the last emitted instruction
// Used for optimizations (e.g., removing unnecessary OpPop)
func (c *Compiler) RemoveLastInstruction() {
	if len(c.instructions) == 0 {
		return
	}

	c.instructions = c.instructions[:c.lastInstruction.Position]
	c.lastInstruction = c.previousInstruction
}

// ========================================
// Program Assembly
// ========================================

// Bytecode represents the compiled bytecode program
type Bytecode struct {
	Instructions vm.Instructions
	Constants    []interface{}
}

// Bytecode assembles and returns the final compiled bytecode
func (c *Compiler) Bytecode() *Bytecode {
	return &Bytecode{
		Instructions: c.instructions,
		Constants:    c.constants,
	}
}

// ========================================
// Compilation Entry Point
// ========================================

// Compile compiles an AST program into bytecode
func (c *Compiler) Compile(node ast.Node) error {
	switch node := node.(type) {
	case *ast.Program:
		for _, stmt := range node.Statements {
			if err := c.Compile(stmt); err != nil {
				return err
			}
		}
		return nil

	// Statements
	case *ast.ExpressionStatement:
		if err := c.Compile(node.Expression); err != nil {
			return err
		}
		// Pop the result since expression statements don't use their value
		c.Emit(vm.OpFree, vm.TmpVarOperand(0)) // TODO: track temp var numbers properly
		return nil

	case *ast.BlockStatement:
		for _, stmt := range node.Statements {
			if err := c.Compile(stmt); err != nil {
				return err
			}
		}
		return nil

	case *ast.EchoStatement:
		for _, expr := range node.Expressions {
			if err := c.Compile(expr); err != nil {
				return err
			}
			// Emit ECHO instruction for each expression
			c.EmitWithLine(vm.OpEcho, uint32(node.Token.Pos.Line), vm.TmpVarOperand(0))
		}
		return nil

	case *ast.ReturnStatement:
		if node.ReturnValue != nil {
			if err := c.Compile(node.ReturnValue); err != nil {
				return err
			}
			c.EmitWithLine(vm.OpReturn, uint32(node.Token.Pos.Line), vm.TmpVarOperand(0))
		} else {
			// Return null
			c.EmitWithLine(vm.OpReturn, uint32(node.Token.Pos.Line))
		}
		return nil

	// Literals
	case *ast.IntegerLiteral:
		constIdx := c.AddConstant(node.Value)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	case *ast.FloatLiteral:
		constIdx := c.AddConstant(node.Value)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	case *ast.StringLiteral:
		constIdx := c.AddConstant(node.Value)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	case *ast.BooleanLiteral:
		constIdx := c.AddConstant(node.Value)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	case *ast.NullLiteral:
		constIdx := c.AddConstant(nil)
		c.EmitWithLine(vm.OpQMAssign, uint32(node.Token.Pos.Line),
			vm.ConstOperand(uint32(constIdx)),
			vm.UnusedOperand(),
			vm.TmpVarOperand(0))
		return nil

	// Infix Expressions (binary operators)
	case *ast.InfixExpression:
		// Compile left operand
		if err := c.Compile(node.Left); err != nil {
			return err
		}
		leftTemp := vm.TmpVarOperand(0) // TODO: proper temp tracking

		// Compile right operand
		if err := c.Compile(node.Right); err != nil {
			return err
		}
		rightTemp := vm.TmpVarOperand(1) // TODO: proper temp tracking

		// Emit the appropriate opcode based on operator
		var opcode vm.Opcode
		switch node.Operator {
		case "+":
			opcode = vm.OpAdd
		case "-":
			opcode = vm.OpSub
		case "*":
			opcode = vm.OpMul
		case "/":
			opcode = vm.OpDiv
		case "%":
			opcode = vm.OpMod
		case "**":
			opcode = vm.OpPow
		case ".":
			opcode = vm.OpConcat
		case "==":
			opcode = vm.OpIsEqual
		case "!=":
			opcode = vm.OpIsNotEqual
		case "===":
			opcode = vm.OpIsIdentical
		case "!==":
			opcode = vm.OpIsNotIdentical
		case "<":
			opcode = vm.OpIsSmaller
		case "<=":
			opcode = vm.OpIsSmallerOrEqual
		case ">":
			// Swap operands and use IS_SMALLER
			opcode = vm.OpIsSmaller
			leftTemp, rightTemp = rightTemp, leftTemp
		case ">=":
			// Swap operands and use IS_SMALLER_OR_EQUAL
			opcode = vm.OpIsSmallerOrEqual
			leftTemp, rightTemp = rightTemp, leftTemp
		case "|":
			opcode = vm.OpBWOr
		case "&":
			opcode = vm.OpBWAnd
		case "^":
			opcode = vm.OpBWXor
		case "<<":
			opcode = vm.OpSL
		case ">>":
			opcode = vm.OpSR
		case "<=>":
			opcode = vm.OpSpaceship
		default:
			return fmt.Errorf("unknown infix operator: %s", node.Operator)
		}

		c.EmitWithLine(opcode, uint32(node.Token.Pos.Line),
			leftTemp,
			rightTemp,
			vm.TmpVarOperand(2)) // Result in temp 2
		return nil

	// Prefix Expressions (unary operators)
	case *ast.PrefixExpression:
		// Compile operand
		if err := c.Compile(node.Right); err != nil {
			return err
		}

		// Emit the appropriate opcode
		var opcode vm.Opcode
		switch node.Operator {
		case "!":
			opcode = vm.OpBoolNot
		case "-":
			// Unary minus: 0 - operand
			constIdx := c.AddConstant(int64(0))
			c.EmitWithLine(vm.OpSub, uint32(node.Token.Pos.Line),
				vm.ConstOperand(uint32(constIdx)),
				vm.TmpVarOperand(0),
				vm.TmpVarOperand(1))
			return nil
		case "~":
			opcode = vm.OpBWNot
		default:
			return fmt.Errorf("unknown prefix operator: %s", node.Operator)
		}

		c.EmitWithLine(opcode, uint32(node.Token.Pos.Line),
			vm.TmpVarOperand(0),
			vm.UnusedOperand(),
			vm.TmpVarOperand(1))
		return nil

	case *ast.Variable:
		// For now, just emit a placeholder
		// Will be properly implemented in symbol table phase
		return fmt.Errorf("variable compilation not yet implemented: $%s", node.Name)

	default:
		return fmt.Errorf("compilation not yet implemented for node type: %T", node)
	}
}

// ========================================
// Helper Methods
// ========================================

// Instructions returns the current instruction list
func (c *Compiler) Instructions() vm.Instructions {
	return c.instructions
}

// Reset resets the compiler state for a new compilation
func (c *Compiler) Reset() {
	c.instructions = vm.Instructions{}
	c.constants = []interface{}{}
	c.constantMap = make(map[interface{}]int)
	c.lastInstruction = EmittedInstruction{}
	c.previousInstruction = EmittedInstruction{}
}
